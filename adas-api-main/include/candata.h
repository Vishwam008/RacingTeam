/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 37.1.0 Thu Mar  2 12:37:48 2023.
 */

#ifndef CANDATA_H
#define CANDATA_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define CANDATA_VCU2_AI_STATUS_FRAME_ID (0x520u)
#define CANDATA_VCU2_AI_STEER_FRAME_ID (0x523u)
#define CANDATA_VCU2_AI_DRIVE_F_FRAME_ID (0x521u)
#define CANDATA_VCU2_AI_DRIVE_R_FRAME_ID (0x522u)
#define CANDATA_AI2_VCU_DRIVE_F_FRAME_ID (0x511u)
#define CANDATA_VCU2_AI_SPEEDS_FRAME_ID (0x525u)
#define CANDATA_AI2_VCU_STATUS_FRAME_ID (0x510u)
#define CANDATA_VCU2_LOG_DYNAMICS1_FRAME_ID (0x500u)
#define CANDATA_AI2_LOG_DYNAMICS2_FRAME_ID (0x501u)
#define CANDATA_VCU2_LOG_STATUS_FRAME_ID (0x502u)
#define CANDATA_AI2_VCU_STEER_FRAME_ID (0x513u)
#define CANDATA_AI2_VCU_BRAKE_FRAME_ID (0x514u)
#define CANDATA_VCU2_AI_BRAKE_FRAME_ID (0x524u)
#define CANDATA_AI2_VCU_DRIVE_R_FRAME_ID (0x512u)
#define CANDATA_VCU2_AI_WHEEL_COUNTS_FRAME_ID (0x526u)
#define CANDATA_VCU_STATUS_FRAME_ID (0x120u)

/* Frame lengths in bytes. */
#define CANDATA_VCU2_AI_STATUS_LENGTH (8u)
#define CANDATA_VCU2_AI_STEER_LENGTH (6u)
#define CANDATA_VCU2_AI_DRIVE_F_LENGTH (6u)
#define CANDATA_VCU2_AI_DRIVE_R_LENGTH (6u)
#define CANDATA_AI2_VCU_DRIVE_F_LENGTH (4u)
#define CANDATA_VCU2_AI_SPEEDS_LENGTH (8u)
#define CANDATA_AI2_VCU_STATUS_LENGTH (8u)
#define CANDATA_VCU2_LOG_DYNAMICS1_LENGTH (8u)
#define CANDATA_AI2_LOG_DYNAMICS2_LENGTH (6u)
#define CANDATA_VCU2_LOG_STATUS_LENGTH (5u)
#define CANDATA_AI2_VCU_STEER_LENGTH (2u)
#define CANDATA_AI2_VCU_BRAKE_LENGTH (2u)
#define CANDATA_VCU2_AI_BRAKE_LENGTH (5u)
#define CANDATA_AI2_VCU_DRIVE_R_LENGTH (4u)
#define CANDATA_VCU2_AI_WHEEL_COUNTS_LENGTH (8u)
#define CANDATA_VCU_STATUS_LENGTH (8u)

/* Extended or standard frame types. */
#define CANDATA_VCU2_AI_STATUS_IS_EXTENDED (0)
#define CANDATA_VCU2_AI_STEER_IS_EXTENDED (0)
#define CANDATA_VCU2_AI_DRIVE_F_IS_EXTENDED (0)
#define CANDATA_VCU2_AI_DRIVE_R_IS_EXTENDED (0)
#define CANDATA_AI2_VCU_DRIVE_F_IS_EXTENDED (0)
#define CANDATA_VCU2_AI_SPEEDS_IS_EXTENDED (0)
#define CANDATA_AI2_VCU_STATUS_IS_EXTENDED (0)
#define CANDATA_VCU2_LOG_DYNAMICS1_IS_EXTENDED (0)
#define CANDATA_AI2_LOG_DYNAMICS2_IS_EXTENDED (0)
#define CANDATA_VCU2_LOG_STATUS_IS_EXTENDED (0)
#define CANDATA_AI2_VCU_STEER_IS_EXTENDED (0)
#define CANDATA_AI2_VCU_BRAKE_IS_EXTENDED (0)
#define CANDATA_VCU2_AI_BRAKE_IS_EXTENDED (0)
#define CANDATA_AI2_VCU_DRIVE_R_IS_EXTENDED (0)
#define CANDATA_VCU2_AI_WHEEL_COUNTS_IS_EXTENDED (0)
#define CANDATA_VCU_STATUS_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define CANDATA_VCU2_AI_STATUS_CYCLE_TIME_MS (10u)
#define CANDATA_VCU2_AI_STEER_CYCLE_TIME_MS (10u)
#define CANDATA_VCU2_AI_DRIVE_F_CYCLE_TIME_MS (10u)
#define CANDATA_VCU2_AI_DRIVE_R_CYCLE_TIME_MS (10u)
#define CANDATA_AI2_VCU_DRIVE_F_CYCLE_TIME_MS (10u)
#define CANDATA_VCU2_AI_SPEEDS_CYCLE_TIME_MS (10u)
#define CANDATA_AI2_VCU_STATUS_CYCLE_TIME_MS (10u)
#define CANDATA_VCU2_LOG_DYNAMICS1_CYCLE_TIME_MS (10u)
#define CANDATA_AI2_LOG_DYNAMICS2_CYCLE_TIME_MS (10u)
#define CANDATA_VCU2_LOG_STATUS_CYCLE_TIME_MS (100u)
#define CANDATA_AI2_VCU_STEER_CYCLE_TIME_MS (10u)
#define CANDATA_AI2_VCU_BRAKE_CYCLE_TIME_MS (10u)
#define CANDATA_VCU2_AI_BRAKE_CYCLE_TIME_MS (10u)
#define CANDATA_AI2_VCU_DRIVE_R_CYCLE_TIME_MS (10u)
#define CANDATA_VCU2_AI_WHEEL_COUNTS_CYCLE_TIME_MS (10u)
#define CANDATA_VCU_STATUS_CYCLE_TIME_MS (10u)

/* Signal choices. */
#define CANDATA_VCU2_AI_STATUS_SHUTDOWN_REQUEST_NO_SHUTDOWN_CHOICE (0u)
#define CANDATA_VCU2_AI_STATUS_SHUTDOWN_REQUEST_SHUTDOWN_REQUESTED_CHOICE (1u)

#define CANDATA_VCU2_AI_STATUS_AS_SWITCH_STATUS_OFF_CHOICE (0u)
#define CANDATA_VCU2_AI_STATUS_AS_SWITCH_STATUS_ON_CHOICE (1u)

#define CANDATA_VCU2_AI_STATUS_TS_SWITCH_STATUS_OFF_CHOICE (0u)
#define CANDATA_VCU2_AI_STATUS_TS_SWITCH_STATUS_ON_CHOICE (1u)

#define CANDATA_VCU2_AI_STATUS_GO_SIGNAL_NO_GO_CHOICE (0u)
#define CANDATA_VCU2_AI_STATUS_GO_SIGNAL_GO_CHOICE (1u)

#define CANDATA_VCU2_AI_STATUS_STEERING_STATUS_OFF_CHOICE (0u)
#define CANDATA_VCU2_AI_STATUS_STEERING_STATUS_ACTIVE_CHOICE (1u)

#define CANDATA_VCU2_AI_STATUS_AS_STATE_AS_OFF_CHOICE (1u)
#define CANDATA_VCU2_AI_STATUS_AS_STATE_AS_READY_CHOICE (2u)
#define CANDATA_VCU2_AI_STATUS_AS_STATE_AS_DRIVING_CHOICE (3u)
#define CANDATA_VCU2_AI_STATUS_AS_STATE_EMERGENCY_BRAKE_CHOICE (4u)
#define CANDATA_VCU2_AI_STATUS_AS_STATE_AS_FINISHED_CHOICE (5u)

#define CANDATA_VCU2_AI_STATUS_AMI_STATE_NOT_SELECTED_CHOICE (0u)
#define CANDATA_VCU2_AI_STATUS_AMI_STATE_ACCELERATION_CHOICE (1u)
#define CANDATA_VCU2_AI_STATUS_AMI_STATE_SKIDPAD_CHOICE (2u)
#define CANDATA_VCU2_AI_STATUS_AMI_STATE_AUTOCROSS_CHOICE (3u)
#define CANDATA_VCU2_AI_STATUS_AMI_STATE_TRACK_DRIVE_CHOICE (4u)
#define CANDATA_VCU2_AI_STATUS_AMI_STATE_STATIC_INSPECTION_A_CHOICE (5u)
#define CANDATA_VCU2_AI_STATUS_AMI_STATE_STATIC_INSPECTION_B_CHOICE (6u)
#define CANDATA_VCU2_AI_STATUS_AMI_STATE_AUTONOMOUS_DEMO_CHOICE (7u)

#define CANDATA_VCU2_AI_STATUS_FAULT_STATUS_NO_FAULT_CHOICE (0u)
#define CANDATA_VCU2_AI_STATUS_FAULT_STATUS_FAULT_DETECTED_CHOICE (1u)

#define CANDATA_VCU2_AI_STATUS_WARNING_STATUS_NO_WARNING_CHOICE (0u)
#define CANDATA_VCU2_AI_STATUS_WARNING_STATUS_WARNING_ACTIVE_CHOICE (1u)

#define CANDATA_VCU2_AI_STATUS_WARN_BATT_TEMP_HIGH_FALSE_CHOICE (0u)
#define CANDATA_VCU2_AI_STATUS_WARN_BATT_TEMP_HIGH_TRUE_CHOICE (1u)

#define CANDATA_VCU2_AI_STATUS_WARN_BATT_SOC_LOW_FALSE_CHOICE (0u)
#define CANDATA_VCU2_AI_STATUS_WARN_BATT_SOC_LOW_TRUE_CHOICE (1u)

#define CANDATA_VCU2_AI_STATUS_AI_ESTOP_REQUEST_FALSE_CHOICE (0u)
#define CANDATA_VCU2_AI_STATUS_AI_ESTOP_REQUEST_TRUE_CHOICE (1u)

#define CANDATA_VCU2_AI_STATUS_HVIL_OPEN_FAULT_FALSE_CHOICE (0u)
#define CANDATA_VCU2_AI_STATUS_HVIL_OPEN_FAULT_TRUE_CHOICE (1u)

#define CANDATA_VCU2_AI_STATUS_HVIL_SHORT_FAULT_FALSE_CHOICE (0u)
#define CANDATA_VCU2_AI_STATUS_HVIL_SHORT_FAULT_TRUE_CHOICE (1u)

#define CANDATA_VCU2_AI_STATUS_EBS_FAULT_FALSE_CHOICE (0u)
#define CANDATA_VCU2_AI_STATUS_EBS_FAULT_TRUE_CHOICE (1u)

#define CANDATA_VCU2_AI_STATUS_OFFBOARD_CHARGER_FAULT_FALSE_CHOICE (0u)
#define CANDATA_VCU2_AI_STATUS_OFFBOARD_CHARGER_FAULT_TRUE_CHOICE (1u)

#define CANDATA_VCU2_AI_STATUS_AI_COMMS_LOST_FALSE_CHOICE (0u)
#define CANDATA_VCU2_AI_STATUS_AI_COMMS_LOST_TRUE_CHOICE (1u)

#define CANDATA_VCU2_AI_STATUS_AUTONOMOUS_BRAKING_FAULT_FALSE_CHOICE (0u)
#define CANDATA_VCU2_AI_STATUS_AUTONOMOUS_BRAKING_FAULT_TRUE_CHOICE (1u)

#define CANDATA_VCU2_AI_STATUS_MISSION_STATUS_FAULT_FALSE_CHOICE (0u)
#define CANDATA_VCU2_AI_STATUS_MISSION_STATUS_FAULT_TRUE_CHOICE (1u)

#define CANDATA_VCU2_AI_STATUS_CHARGE_PROCEDURE_FAULT_FALSE_CHOICE (0u)
#define CANDATA_VCU2_AI_STATUS_CHARGE_PROCEDURE_FAULT_TRUE_CHOICE (1u)

#define CANDATA_VCU2_AI_STATUS_BMS_FAULT_FALSE_CHOICE (0u)
#define CANDATA_VCU2_AI_STATUS_BMS_FAULT_TRUE_CHOICE (1u)

#define CANDATA_VCU2_AI_STATUS_BRAKE_PLAUSIBILITY_FAULT_FALSE_CHOICE (0u)
#define CANDATA_VCU2_AI_STATUS_BRAKE_PLAUSIBILITY_FAULT_TRUE_CHOICE (1u)

#define CANDATA_VCU2_AI_STATUS_SHUTDOWN_CAUSE_NO_SHUTDOWN_CHOICE (0u)
#define CANDATA_VCU2_AI_STATUS_SHUTDOWN_CAUSE_AI_COMPUTER_REQUEST_CHOICE (1u)
#define CANDATA_VCU2_AI_STATUS_SHUTDOWN_CAUSE_HVIL_OPEN_FAULT_CHOICE (2u)
#define CANDATA_VCU2_AI_STATUS_SHUTDOWN_CAUSE_HVIL_SHORT_FAULT_CHOICE (3u)
#define CANDATA_VCU2_AI_STATUS_SHUTDOWN_CAUSE_EBS_FAULT_CHOICE (4u)
#define CANDATA_VCU2_AI_STATUS_SHUTDOWN_CAUSE_OFFBOARD_CHARGER_FAULT_CHOICE (5u)
#define CANDATA_VCU2_AI_STATUS_SHUTDOWN_CAUSE_AI_COMMS_FAULT_CHOICE (6u)
#define CANDATA_VCU2_AI_STATUS_SHUTDOWN_CAUSE_AUTONOMOUS_BRAKING_FAULT_CHOICE (7u)
#define CANDATA_VCU2_AI_STATUS_SHUTDOWN_CAUSE_MISSION_STATUS_FAULT_CHOICE (8u)
#define CANDATA_VCU2_AI_STATUS_SHUTDOWN_CAUSE_CHARGE_PROCEDURE_FAULT_CHOICE (9u)
#define CANDATA_VCU2_AI_STATUS_SHUTDOWN_CAUSE_BMS_FAULT_CHOICE (10u)
#define CANDATA_VCU2_AI_STATUS_SHUTDOWN_CAUSE_BRAKE_PLAUSIBILITY_FAULT_CHOICE (11u)

#define CANDATA_AI2_VCU_STATUS_ESTOP_REQUEST_NO_SHUTDOWN_CHOICE (0u)
#define CANDATA_AI2_VCU_STATUS_ESTOP_REQUEST_SHUTDOWN_REQUESTED_CHOICE (1u)

#define CANDATA_AI2_VCU_STATUS_MISSION_STATUS_NOT_SELECTED_CHOICE (0u)
#define CANDATA_AI2_VCU_STATUS_MISSION_STATUS_SELECTED_CHOICE (1u)
#define CANDATA_AI2_VCU_STATUS_MISSION_STATUS_RUNNING_CHOICE (2u)
#define CANDATA_AI2_VCU_STATUS_MISSION_STATUS_FINISHED_CHOICE (3u)

#define CANDATA_AI2_VCU_STATUS_DIRECTION_REQUEST_NEUTRAL_CHOICE (0u)
#define CANDATA_AI2_VCU_STATUS_DIRECTION_REQUEST_FORWARD_CHOICE (1u)
#define CANDATA_AI2_VCU_STATUS_DIRECTION_REQUEST_REVERSE_CHOICE (2u)

#define CANDATA_VCU2_LOG_STATUS_STATE_ASSI_OFF_CHOICE (1u)
#define CANDATA_VCU2_LOG_STATUS_STATE_ASSI_READY_CHOICE (2u)
#define CANDATA_VCU2_LOG_STATUS_STATE_ASSI_DRIVING_CHOICE (3u)
#define CANDATA_VCU2_LOG_STATUS_STATE_ASSI_EMERGENCY_BRAKE_CHOICE (4u)
#define CANDATA_VCU2_LOG_STATUS_STATE_ASSI_FINISH_CHOICE (5u)

#define CANDATA_VCU2_LOG_STATUS_STATE_EBS_UNAVAILABLE_CHOICE (1u)
#define CANDATA_VCU2_LOG_STATUS_STATE_EBS_ARMED_CHOICE (2u)
#define CANDATA_VCU2_LOG_STATUS_STATE_EBS_TRIGGERED_CHOICE (3u)

#define CANDATA_VCU2_LOG_STATUS_AMI_STATE_NOT_SELECTED_CHOICE (0u)
#define CANDATA_VCU2_LOG_STATUS_AMI_STATE_ACCELERATION_CHOICE (1u)
#define CANDATA_VCU2_LOG_STATUS_AMI_STATE_SKIDPAD_CHOICE (2u)
#define CANDATA_VCU2_LOG_STATUS_AMI_STATE_AUTOCROSS_CHOICE (3u)
#define CANDATA_VCU2_LOG_STATUS_AMI_STATE_TRACK_DRIVE_CHOICE (4u)
#define CANDATA_VCU2_LOG_STATUS_AMI_STATE_STATIC_INSPECTION_A_CHOICE (5u)
#define CANDATA_VCU2_LOG_STATUS_AMI_STATE_STATIC_INSPECTION_B_CHOICE (6u)
#define CANDATA_VCU2_LOG_STATUS_AMI_STATE_AUTONOMOUS_DEMO_CHOICE (7u)

#define CANDATA_VCU2_LOG_STATUS_STATE_STEERING_OFF_CHOICE (0u)
#define CANDATA_VCU2_LOG_STATUS_STATE_STEERING_ON_CHOICE (1u)

#define CANDATA_VCU2_LOG_STATUS_STATE_SERVICE_BRAKE_DISENGAGED_CHOICE (1u)
#define CANDATA_VCU2_LOG_STATUS_STATE_SERVICE_BRAKE_ENGAGED_CHOICE (2u)
#define CANDATA_VCU2_LOG_STATUS_STATE_SERVICE_BRAKE_AVAILABLE_CHOICE (3u)

#define CANDATA_VCU2_AI_BRAKE_STATUS_BRK_INITIALISING_CHOICE (0u)
#define CANDATA_VCU2_AI_BRAKE_STATUS_BRK_READY_CHOICE (1u)
#define CANDATA_VCU2_AI_BRAKE_STATUS_BRK_SHUTTING_DOWN_CHOICE (2u)
#define CANDATA_VCU2_AI_BRAKE_STATUS_BRK_SHUTDOWN_COMPLETE_CHOICE (3u)
#define CANDATA_VCU2_AI_BRAKE_STATUS_BRK_FAULT_CHOICE (4u)

#define CANDATA_VCU2_AI_BRAKE_STATUS_EBS_UNAVAILABLE_CHOICE (1u)
#define CANDATA_VCU2_AI_BRAKE_STATUS_EBS_ARMED_CHOICE (2u)
#define CANDATA_VCU2_AI_BRAKE_STATUS_EBS_TRIGGERED_CHOICE (3u)

#define CANDATA_VCU_STATUS_SM_SYS_INITIAL_ACTIONS_CHOICE (0u)
#define CANDATA_VCU_STATUS_SM_SYS_POWER_ON_SELF_TEST_CHOICE (1u)
#define CANDATA_VCU_STATUS_SM_SYS_AUX_CHOICE (2u)
#define CANDATA_VCU_STATUS_SM_SYS_POWERTRAIN_ENABLE_CHOICE (3u)
#define CANDATA_VCU_STATUS_SM_SYS_DRIVE_AUTONOMOUS_CHOICE (4u)
#define CANDATA_VCU_STATUS_SM_SYS_DRIVE_MANUAL_CHOICE (5u)
#define CANDATA_VCU_STATUS_SM_SYS_CHARGE_CHOICE (6u)
#define CANDATA_VCU_STATUS_SM_SYS_SHUTDOWN_CHOICE (7u)
#define CANDATA_VCU_STATUS_SM_SYS_SHUTDOWN_OFF_CHOICE (8u)
#define CANDATA_VCU_STATUS_SM_SYS_PUSHBAR_MODE_CHOICE (9u)

#define CANDATA_VCU_STATUS_SM_AS_AS_OFF_CHOICE (1u)
#define CANDATA_VCU_STATUS_SM_AS_AS_READY_CHOICE (2u)
#define CANDATA_VCU_STATUS_SM_AS_AS_DRIVING_CHOICE (3u)
#define CANDATA_VCU_STATUS_SM_AS_AS_EMERGENCY_BRAKE_CHOICE (4u)
#define CANDATA_VCU_STATUS_SM_AS_AS_FINISHED_CHOICE (5u)
#define CANDATA_VCU_STATUS_SM_AS_AS_R2_D_CHOICE (6u)

#define CANDATA_VCU_STATUS_R1_AI2_VCU_STATUS_TIMEOUT_ERROR_FALSE_CHOICE (0u)
#define CANDATA_VCU_STATUS_R1_AI2_VCU_STATUS_TIMEOUT_ERROR_TRUE_CHOICE (1u)

#define CANDATA_VCU_STATUS_R1_AI2_VCU_DRIVE_F_TIMEOUT_ERROR_FALSE_CHOICE (0u)
#define CANDATA_VCU_STATUS_R1_AI2_VCU_DRIVE_F_TIMEOUT_ERROR_TRUE_CHOICE (1u)

#define CANDATA_VCU_STATUS_R1_AI2_VCU_DRIVE_R_TIMEOUT_ERROR_FALSE_CHOICE (0u)
#define CANDATA_VCU_STATUS_R1_AI2_VCU_DRIVE_R_TIMEOUT_ERROR_TRUE_CHOICE (1u)

#define CANDATA_VCU_STATUS_R1_AI2_VCU_STATUS_HANDSHAKE_TIMEOUT_ERROR_FALSE_CHOICE (0u)
#define CANDATA_VCU_STATUS_R1_AI2_VCU_STATUS_HANDSHAKE_TIMEOUT_ERROR_TRUE_CHOICE (1u)

#define CANDATA_VCU_STATUS_R1_AI2_VCU_STEER_TIMEOUT_ERROR_FALSE_CHOICE (0u)
#define CANDATA_VCU_STATUS_R1_AI2_VCU_STEER_TIMEOUT_ERROR_TRUE_CHOICE (1u)

#define CANDATA_VCU_STATUS_R1_AI2_VCU_BRAKE_TIMEOUT_ERROR_FALSE_CHOICE (0u)
#define CANDATA_VCU_STATUS_R1_AI2_VCU_BRAKE_TIMEOUT_ERROR_TRUE_CHOICE (1u)

#define CANDATA_VCU_STATUS_SYS_ACTION_STATE_INITIALISE_CHOICE (0u)
#define CANDATA_VCU_STATUS_SYS_ACTION_STATE_CHARGE_CHOICE (1u)
#define CANDATA_VCU_STATUS_SYS_ACTION_STATE_DRIVE_AUTO_CHOICE (2u)
#define CANDATA_VCU_STATUS_SYS_ACTION_STATE_DRIVE_MAN_CHOICE (3u)
#define CANDATA_VCU_STATUS_SYS_ACTION_STATE_SHUTDOWN_CHOICE (4u)

#define CANDATA_VCU_STATUS_WARN_BRAKE_PLAUSIBILITY_FALSE_CHOICE (0u)
#define CANDATA_VCU_STATUS_WARN_BRAKE_PLAUSIBILITY_TRUE_CHOICE (1u)

#define CANDATA_VCU_STATUS_WARN_KL15_UNDER_V_FALSE_CHOICE (0u)
#define CANDATA_VCU_STATUS_WARN_KL15_UNDER_V_TRUE_CHOICE (1u)

#define CANDATA_VCU_STATUS_WARN_AI_ESTOP_REQ_FALSE_CHOICE (0u)
#define CANDATA_VCU_STATUS_WARN_AI_ESTOP_REQ_TRUE_CHOICE (1u)

#define CANDATA_VCU_STATUS_WARN_AI_COMMS_LOST_FALSE_CHOICE (0u)
#define CANDATA_VCU_STATUS_WARN_AI_COMMS_LOST_TRUE_CHOICE (1u)

#define CANDATA_VCU_STATUS_WARN_AUTO_BRAKING_FALSE_CHOICE (0u)
#define CANDATA_VCU_STATUS_WARN_AUTO_BRAKING_TRUE_CHOICE (1u)

#define CANDATA_VCU_STATUS_WARN_MISSION_STATUS_FALSE_CHOICE (0u)
#define CANDATA_VCU_STATUS_WARN_MISSION_STATUS_TRUE_CHOICE (1u)

/**
 * Signals in message VCU2AI_Status.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
struct candata_vcu2_ai_status_t {
    /**
     * Handshake
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t handshake;

    /**
     * Shutdown request to AI
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t shutdown_request;

    /**
     * Autonomous System switch status
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t as_switch_status;

    /**
     * Tractive System switch status
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ts_switch_status;

    /**
     * Autonomous System "Go" signal
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t go_signal;

    /**
     * State of the steering system
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t steering_status;

    /**
     * State of the Autonomous System
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t as_state;

    /**
     * State of the Mission Indicator
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ami_state;

    /**
     * System fault status
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fault_status;

    /**
     * System warning status
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warning_status;

    /**
     * High traction battery temperature warning
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_batt_temp_high;

    /**
     * Low traction battery SOC warning
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_batt_soc_low;

    /**
     * AI system E-stop request
     *
     * Range: 0..1 (0..1 __F__)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ai_estop_request;

    /**
     * HVIL open-circuit fault
     *
     * Range: 0..1 (0..1 __F__)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hvil_open_fault;

    /**
     * HVIL short-circuit fault
     *
     * Range: 0..1 (0..1 __F__)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hvil_short_fault;

    /**
     * EBS fault
     *
     * Range: 0..1 (0..1 __F__)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_fault;

    /**
     * Offboard charger fault
     *
     * Range: 0..1 (0..1 __F__)
     * Scale: 1
     * Offset: 0
     */
    uint8_t offboard_charger_fault;

    /**
     * AI CAN communications fault
     *
     * Range: 0..1 (0..1 __F__)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ai_comms_lost;

    /**
     * Braking in Autonomous Driving mode fault
     *
     * Range: 0..1 (0..1 __F__)
     * Scale: 1
     * Offset: 0
     */
    uint8_t autonomous_braking_fault;

    /**
     * Autonomous mission status fault
     *
     * Range: 0..1 (0..1 __F__)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mission_status_fault;

    /**
     * Battery charging procedure fault
     *
     * Range: 0..1 (0..1 __F__)
     * Scale: 1
     * Offset: 0
     */
    uint8_t charge_procedure_fault;

    /**
     * BMS fault detected
     *
     * Range: 0..1 (0..1 __F__)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bms_fault;

    /**
     * Brake plausibility fault
     *
     * Range: 0..1 (0..1 __F__)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_plausibility_fault;

    /**
     * Enumerated list of shutdown faults
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t shutdown_cause;
};

/**
 * Signals in message VCU2AI_Steer.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
struct candata_vcu2_ai_steer_t {
    /**
     * Steer Angle
     *
     * Range: -210..210 (-21..21 deg)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t angle;

    /**
     * Steer Angle Max
     *
     * Range: 0..210 (0..21 deg)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t angle_max;

    /**
     * Steer Angle Request
     *
     * Range: -210..210 (-21..21 deg)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t angle_request;
};

/**
 * Signals in message VCU2AI_Drive_F.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
struct candata_vcu2_ai_drive_f_t {
    /**
     * Current front axle torque
     *
     * Range: -1950..1950 (-195..195 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t front_axle_trq;

    /**
     * Requested front axle torque
     *
     * Range: 0..1950 (0..195 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t front_axle_trq_request;

    /**
     * Maximum front axle drive torque
     *
     * Range: 0..1950 (0..195 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t front_axle_trq_max;
};

/**
 * Signals in message VCU2AI_Drive_R.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
struct candata_vcu2_ai_drive_r_t {
    /**
     * Current rear axle torque
     *
     * Range: -1950..1950 (-195..195 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t rear_axle_trq;

    /**
     * Requested rear axle torque
     *
     * Range: 0..1950 (0..195 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t rear_axle_trq_request;

    /**
     * Maximum rear axle drive torque
     *
     * Range: 0..1950 (0..195 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t rear_axle_trq_max;
};

/**
 * Signals in message AI2VCU_Drive_F.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
struct candata_ai2_vcu_drive_f_t {
    /**
     * Requested front axle torque
     *
     * Range: 0..1950 (0..195 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t front_axle_trq_request;

    /**
     * Range: 0..4000 (0..4000 rpm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t front_motor_speed_max;
};

/**
 * Signals in message VCU2AI_Speeds.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
struct candata_vcu2_ai_speeds_t {
    /**
     * Range: 0..1250 (0..1250 rpm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fl_wheel_speed;

    /**
     * Range: 0..1250 (0..1250 rpm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fr_wheel_speed;

    /**
     * Range: 0..1250 (0..1250 rpm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t rl_wheel_speed;

    /**
     * Range: 0..1250 (0..1250 rpm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t rr_wheel_speed;
};

/**
 * Signals in message AI2VCU_Status.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
struct candata_ai2_vcu_status_t {
    /**
     * Handshake
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t handshake;

    /**
     * Shutdown request to VCU
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t estop_request;

    /**
     * Autonomous mission status
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mission_status;

    /**
     * Requested vehicle direction
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t direction_request;

    /**
     * Lap counter
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lap_counter;

    /**
     * Number of cones detected
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cones_count_actual;

    /**
     * Total number of cones detected
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t cones_count_all;

    /**
     * Range: 0..255 (0..255 km/h)
     * Scale: 1
     * Offset: 0
     */
    uint8_t veh_speed_actual;

    /**
     * Range: 0..255 (0..255 km/h)
     * Scale: 1
     * Offset: 0
     */
    uint8_t veh_speed_demand;
};

/**
 * Signals in message VCU2LOG_Dynamics1.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
struct candata_vcu2_log_dynamics1_t {
    /**
     * Range: 0..255 (0..255 km/h)
     * Scale: 1
     * Offset: 0
     */
    uint8_t speed_actual;

    /**
     * Range: 0..255 (0..255 km/h)
     * Scale: 1
     * Offset: 0
     */
    uint8_t speed_target;

    /**
     * Range: -128..127 (-64..63.5 deg)
     * Scale: 0.5
     * Offset: 0
     */
    int8_t steer_actual;

    /**
     * Range: -128..127 (-64..63.5 deg)
     * Scale: 0.5
     * Offset: 0
     */
    int8_t steer_target;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_actual_pct;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_target_pct;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t drive_trq_actual_pct;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t drive_trq_target_pct;
};

/**
 * Signals in message AI2LOG_Dynamics2.
 *
 * All signal values are as on the CAN bus.
 */
struct candata_ai2_log_dynamics2_t {
    /**
     * Range: -32767.91611413474781504559348..32766.89211675618110417637331 (-64..63.998 m/s^2)
     * Scale: 0.00195313
     * Offset: 0
     */
    int16_t accel_longitudinal_mps2;

    /**
     * Range: -32767.91611413474781504559348..32766.89211675618110417637331 (-64..63.998 m/s^2)
     * Scale: 0.00195313
     * Offset: 0
     */
    int16_t accel_lateral_mps2;

    /**
     * Range: -32768..32766.976 (-256..255.992 deg/s)
     * Scale: 0.0078125
     * Offset: 0
     */
    int16_t yaw_rate_degps;
};

/**
 * Signals in message VCU2LOG_Status.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
struct candata_vcu2_log_status_t {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t state_assi;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t state_ebs;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ami_state;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t state_steering;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t state_service_brake;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lap_counter;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cones_count_actual;

    /**
     * Range: 0..131071 (0..131071 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t cones_count_all;
};

/**
 * Signals in message AI2VCU_Steer.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
struct candata_ai2_vcu_steer_t {
    /**
     * Range: -210..210 (-21..21 deg)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t steer_request;
};

/**
 * Signals in message AI2VCU_Brake.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
struct candata_ai2_vcu_brake_t {
    /**
     * Requested front axle hydraulic brake pressure
     *
     * Range: 0..200 (0..100 %)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t hyd_press_f_req_pct;

    /**
     * Requested rear axle hydraulic brake pressure
     *
     * Range: 0..200 (0..100 %)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t hyd_press_r_req_pct;
};

/**
 * Signals in message VCU2AI_Brake.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
struct candata_vcu2_ai_brake_t {
    /**
     * Front axle hydraulic brake pressure
     *
     * Range: 0..200 (0..100 %)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t hyd_press_f_pct;

    /**
     * Requested front axle hydraulic brake pressure
     *
     * Range: 0..200 (0..100 %)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t hyd_press_f_req_pct;

    /**
     * Rear axle hydraulic brake pressure
     *
     * Range: 0..200 (0..100 %)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t hyd_press_r_pct;

    /**
     * Requested rear axle hydraulic brake pressure
     *
     * Range: 0..200 (0..100 %)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t hyd_press_r_req_pct;

    /**
     * Braking system status
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t status_brk;

    /**
     * Emergency brake status
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t status_ebs;
};

/**
 * Signals in message AI2VCU_Drive_R.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
struct candata_ai2_vcu_drive_r_t {
    /**
     * Requested rear axle torque
     *
     * Range: 0..1950 (0..195 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t rear_axle_trq_request;

    /**
     * Range: 0..4000 (0..4000 rpm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t rear_motor_speed_max;
};

/**
 * Signals in message VCU2AI_Wheel_counts.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
struct candata_vcu2_ai_wheel_counts_t {
    /**
     * Front left wheel speed pulse count
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fl_pulse_count;

    /**
     * Front right wheel speed pulse count
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fr_pulse_count;

    /**
     * Rear left wheel speed pulse count
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t rl_pulse_count;

    /**
     * Rear right wheel speed pulse count
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t rr_pulse_count;
};

/**
 * Signals in message VCU_STATUS.
 *
 * VCU diagnostic data
 *
 * All signal values are as on the CAN bus.
 */
struct candata_vcu_status_t {
    /**
     * VCU state machine state
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sm_sys;

    /**
     * Drive Auto State Machine
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sm_as;

    /**
     * AI CAN messge lost flag
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t r1_ai2_vcu_status_timeout_error;

    /**
     * AI CAN message lost flag
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t r1_ai2_vcu_drive_f_timeout_error;

    /**
     * AI CAN message lost
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t r1_ai2_vcu_drive_r_timeout_error;

    /**
     * AI handshake fault flag
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t r1_ai2_vcu_status_handshake_timeout_error;

    /**
     * AI CAN message lost flag
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t r1_ai2_vcu_steer_timeout_error;

    /**
     * AI CAN message lost flag
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t r1_ai2_vcu_brake_timeout_error;

    /**
     * Vehicle operating state
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sys_action_state;

    /**
     * Warning brake plausibility
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_brake_plausibility;

    /**
     * Warning KL15 under voltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_kl15_under_v;

    /**
     * Warning Estop Request
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_ai_estop_req;

    /**
     * Warning: AI comms lost
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_ai_comms_lost;

    /**
     * Warning Auto Breaking
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_auto_braking;

    /**
     * Warning Mission Status
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_mission_status;
};

/**
 * Pack message VCU2AI_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int candata_vcu2_ai_status_pack(
    uint8_t *dst_p,
    const struct candata_vcu2_ai_status_t *src_p,
    size_t size);

/**
 * Unpack message VCU2AI_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int candata_vcu2_ai_status_unpack(
    struct candata_vcu2_ai_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_handshake_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_handshake_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_handshake_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_shutdown_request_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_shutdown_request_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_shutdown_request_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_as_switch_status_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_as_switch_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_as_switch_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_ts_switch_status_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_ts_switch_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_ts_switch_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_go_signal_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_go_signal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_go_signal_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_steering_status_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_steering_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_steering_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_as_state_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_as_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_as_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_ami_state_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_ami_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_ami_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_fault_status_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_fault_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_fault_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_warning_status_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_warning_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_warning_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_warn_batt_temp_high_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_warn_batt_temp_high_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_warn_batt_temp_high_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_warn_batt_soc_low_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_warn_batt_soc_low_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_warn_batt_soc_low_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_ai_estop_request_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_ai_estop_request_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_ai_estop_request_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_hvil_open_fault_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_hvil_open_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_hvil_open_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_hvil_short_fault_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_hvil_short_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_hvil_short_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_ebs_fault_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_ebs_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_ebs_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_offboard_charger_fault_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_offboard_charger_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_offboard_charger_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_ai_comms_lost_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_ai_comms_lost_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_ai_comms_lost_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_autonomous_braking_fault_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_autonomous_braking_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_autonomous_braking_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_mission_status_fault_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_mission_status_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_mission_status_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_charge_procedure_fault_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_charge_procedure_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_charge_procedure_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_bms_fault_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_bms_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_bms_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_brake_plausibility_fault_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_brake_plausibility_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_brake_plausibility_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_status_shutdown_cause_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_status_shutdown_cause_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_status_shutdown_cause_is_in_range(uint8_t value);

/**
 * Pack message VCU2AI_Steer.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int candata_vcu2_ai_steer_pack(
    uint8_t *dst_p,
    const struct candata_vcu2_ai_steer_t *src_p,
    size_t size);

/**
 * Unpack message VCU2AI_Steer.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int candata_vcu2_ai_steer_unpack(
    struct candata_vcu2_ai_steer_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t candata_vcu2_ai_steer_angle_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_steer_angle_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_steer_angle_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t candata_vcu2_ai_steer_angle_max_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_steer_angle_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_steer_angle_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t candata_vcu2_ai_steer_angle_request_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_steer_angle_request_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_steer_angle_request_is_in_range(int16_t value);

/**
 * Pack message VCU2AI_Drive_F.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int candata_vcu2_ai_drive_f_pack(
    uint8_t *dst_p,
    const struct candata_vcu2_ai_drive_f_t *src_p,
    size_t size);

/**
 * Unpack message VCU2AI_Drive_F.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int candata_vcu2_ai_drive_f_unpack(
    struct candata_vcu2_ai_drive_f_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t candata_vcu2_ai_drive_f_front_axle_trq_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_drive_f_front_axle_trq_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_drive_f_front_axle_trq_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t candata_vcu2_ai_drive_f_front_axle_trq_request_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_drive_f_front_axle_trq_request_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_drive_f_front_axle_trq_request_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t candata_vcu2_ai_drive_f_front_axle_trq_max_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_drive_f_front_axle_trq_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_drive_f_front_axle_trq_max_is_in_range(uint16_t value);

/**
 * Pack message VCU2AI_Drive_R.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int candata_vcu2_ai_drive_r_pack(
    uint8_t *dst_p,
    const struct candata_vcu2_ai_drive_r_t *src_p,
    size_t size);

/**
 * Unpack message VCU2AI_Drive_R.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int candata_vcu2_ai_drive_r_unpack(
    struct candata_vcu2_ai_drive_r_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t candata_vcu2_ai_drive_r_rear_axle_trq_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_drive_r_rear_axle_trq_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_drive_r_rear_axle_trq_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t candata_vcu2_ai_drive_r_rear_axle_trq_request_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_drive_r_rear_axle_trq_request_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_drive_r_rear_axle_trq_request_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t candata_vcu2_ai_drive_r_rear_axle_trq_max_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_drive_r_rear_axle_trq_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_drive_r_rear_axle_trq_max_is_in_range(uint16_t value);

/**
 * Pack message AI2VCU_Drive_F.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int candata_ai2_vcu_drive_f_pack(
    uint8_t *dst_p,
    const struct candata_ai2_vcu_drive_f_t *src_p,
    size_t size);

/**
 * Unpack message AI2VCU_Drive_F.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int candata_ai2_vcu_drive_f_unpack(
    struct candata_ai2_vcu_drive_f_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t candata_ai2_vcu_drive_f_front_axle_trq_request_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_ai2_vcu_drive_f_front_axle_trq_request_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_ai2_vcu_drive_f_front_axle_trq_request_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t candata_ai2_vcu_drive_f_front_motor_speed_max_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_ai2_vcu_drive_f_front_motor_speed_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_ai2_vcu_drive_f_front_motor_speed_max_is_in_range(uint16_t value);

/**
 * Pack message VCU2AI_Speeds.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int candata_vcu2_ai_speeds_pack(
    uint8_t *dst_p,
    const struct candata_vcu2_ai_speeds_t *src_p,
    size_t size);

/**
 * Unpack message VCU2AI_Speeds.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int candata_vcu2_ai_speeds_unpack(
    struct candata_vcu2_ai_speeds_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t candata_vcu2_ai_speeds_fl_wheel_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_speeds_fl_wheel_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_speeds_fl_wheel_speed_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t candata_vcu2_ai_speeds_fr_wheel_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_speeds_fr_wheel_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_speeds_fr_wheel_speed_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t candata_vcu2_ai_speeds_rl_wheel_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_speeds_rl_wheel_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_speeds_rl_wheel_speed_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t candata_vcu2_ai_speeds_rr_wheel_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_speeds_rr_wheel_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_speeds_rr_wheel_speed_is_in_range(uint16_t value);

/**
 * Pack message AI2VCU_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int candata_ai2_vcu_status_pack(
    uint8_t *dst_p,
    const struct candata_ai2_vcu_status_t *src_p,
    size_t size);

/**
 * Unpack message AI2VCU_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int candata_ai2_vcu_status_unpack(
    struct candata_ai2_vcu_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_ai2_vcu_status_handshake_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_ai2_vcu_status_handshake_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_ai2_vcu_status_handshake_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_ai2_vcu_status_estop_request_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_ai2_vcu_status_estop_request_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_ai2_vcu_status_estop_request_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_ai2_vcu_status_mission_status_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_ai2_vcu_status_mission_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_ai2_vcu_status_mission_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_ai2_vcu_status_direction_request_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_ai2_vcu_status_direction_request_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_ai2_vcu_status_direction_request_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_ai2_vcu_status_lap_counter_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_ai2_vcu_status_lap_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_ai2_vcu_status_lap_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_ai2_vcu_status_cones_count_actual_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_ai2_vcu_status_cones_count_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_ai2_vcu_status_cones_count_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t candata_ai2_vcu_status_cones_count_all_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_ai2_vcu_status_cones_count_all_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_ai2_vcu_status_cones_count_all_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_ai2_vcu_status_veh_speed_actual_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_ai2_vcu_status_veh_speed_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_ai2_vcu_status_veh_speed_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_ai2_vcu_status_veh_speed_demand_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_ai2_vcu_status_veh_speed_demand_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_ai2_vcu_status_veh_speed_demand_is_in_range(uint8_t value);

/**
 * Pack message VCU2LOG_Dynamics1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int candata_vcu2_log_dynamics1_pack(
    uint8_t *dst_p,
    const struct candata_vcu2_log_dynamics1_t *src_p,
    size_t size);

/**
 * Unpack message VCU2LOG_Dynamics1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int candata_vcu2_log_dynamics1_unpack(
    struct candata_vcu2_log_dynamics1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_log_dynamics1_speed_actual_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_log_dynamics1_speed_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_log_dynamics1_speed_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_log_dynamics1_speed_target_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_log_dynamics1_speed_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_log_dynamics1_speed_target_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t candata_vcu2_log_dynamics1_steer_actual_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_log_dynamics1_steer_actual_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_log_dynamics1_steer_actual_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t candata_vcu2_log_dynamics1_steer_target_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_log_dynamics1_steer_target_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_log_dynamics1_steer_target_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_log_dynamics1_brake_actual_pct_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_log_dynamics1_brake_actual_pct_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_log_dynamics1_brake_actual_pct_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_log_dynamics1_brake_target_pct_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_log_dynamics1_brake_target_pct_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_log_dynamics1_brake_target_pct_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_log_dynamics1_drive_trq_actual_pct_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_log_dynamics1_drive_trq_actual_pct_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_log_dynamics1_drive_trq_actual_pct_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_log_dynamics1_drive_trq_target_pct_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_log_dynamics1_drive_trq_target_pct_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_log_dynamics1_drive_trq_target_pct_is_in_range(uint8_t value);

/**
 * Pack message AI2LOG_Dynamics2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int candata_ai2_log_dynamics2_pack(
    uint8_t *dst_p,
    const struct candata_ai2_log_dynamics2_t *src_p,
    size_t size);

/**
 * Unpack message AI2LOG_Dynamics2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int candata_ai2_log_dynamics2_unpack(
    struct candata_ai2_log_dynamics2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t candata_ai2_log_dynamics2_accel_longitudinal_mps2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_ai2_log_dynamics2_accel_longitudinal_mps2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_ai2_log_dynamics2_accel_longitudinal_mps2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t candata_ai2_log_dynamics2_accel_lateral_mps2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_ai2_log_dynamics2_accel_lateral_mps2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_ai2_log_dynamics2_accel_lateral_mps2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t candata_ai2_log_dynamics2_yaw_rate_degps_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_ai2_log_dynamics2_yaw_rate_degps_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_ai2_log_dynamics2_yaw_rate_degps_is_in_range(int16_t value);

/**
 * Pack message VCU2LOG_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int candata_vcu2_log_status_pack(
    uint8_t *dst_p,
    const struct candata_vcu2_log_status_t *src_p,
    size_t size);

/**
 * Unpack message VCU2LOG_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int candata_vcu2_log_status_unpack(
    struct candata_vcu2_log_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_log_status_state_assi_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_log_status_state_assi_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_log_status_state_assi_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_log_status_state_ebs_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_log_status_state_ebs_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_log_status_state_ebs_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_log_status_ami_state_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_log_status_ami_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_log_status_ami_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_log_status_state_steering_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_log_status_state_steering_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_log_status_state_steering_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_log_status_state_service_brake_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_log_status_state_service_brake_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_log_status_state_service_brake_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_log_status_lap_counter_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_log_status_lap_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_log_status_lap_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_log_status_cones_count_actual_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_log_status_cones_count_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_log_status_cones_count_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t candata_vcu2_log_status_cones_count_all_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_log_status_cones_count_all_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_log_status_cones_count_all_is_in_range(uint32_t value);

/**
 * Pack message AI2VCU_Steer.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int candata_ai2_vcu_steer_pack(
    uint8_t *dst_p,
    const struct candata_ai2_vcu_steer_t *src_p,
    size_t size);

/**
 * Unpack message AI2VCU_Steer.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int candata_ai2_vcu_steer_unpack(
    struct candata_ai2_vcu_steer_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t candata_ai2_vcu_steer_steer_request_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_ai2_vcu_steer_steer_request_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_ai2_vcu_steer_steer_request_is_in_range(int16_t value);

/**
 * Pack message AI2VCU_Brake.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int candata_ai2_vcu_brake_pack(
    uint8_t *dst_p,
    const struct candata_ai2_vcu_brake_t *src_p,
    size_t size);

/**
 * Unpack message AI2VCU_Brake.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int candata_ai2_vcu_brake_unpack(
    struct candata_ai2_vcu_brake_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_ai2_vcu_brake_hyd_press_f_req_pct_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_ai2_vcu_brake_hyd_press_f_req_pct_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_ai2_vcu_brake_hyd_press_f_req_pct_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_ai2_vcu_brake_hyd_press_r_req_pct_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_ai2_vcu_brake_hyd_press_r_req_pct_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_ai2_vcu_brake_hyd_press_r_req_pct_is_in_range(uint8_t value);

/**
 * Pack message VCU2AI_Brake.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int candata_vcu2_ai_brake_pack(
    uint8_t *dst_p,
    const struct candata_vcu2_ai_brake_t *src_p,
    size_t size);

/**
 * Unpack message VCU2AI_Brake.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int candata_vcu2_ai_brake_unpack(
    struct candata_vcu2_ai_brake_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_brake_hyd_press_f_pct_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_brake_hyd_press_f_pct_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_brake_hyd_press_f_pct_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_brake_hyd_press_f_req_pct_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_brake_hyd_press_f_req_pct_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_brake_hyd_press_f_req_pct_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_brake_hyd_press_r_pct_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_brake_hyd_press_r_pct_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_brake_hyd_press_r_pct_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_brake_hyd_press_r_req_pct_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_brake_hyd_press_r_req_pct_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_brake_hyd_press_r_req_pct_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_brake_status_brk_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_brake_status_brk_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_brake_status_brk_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu2_ai_brake_status_ebs_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_brake_status_ebs_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_brake_status_ebs_is_in_range(uint8_t value);

/**
 * Pack message AI2VCU_Drive_R.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int candata_ai2_vcu_drive_r_pack(
    uint8_t *dst_p,
    const struct candata_ai2_vcu_drive_r_t *src_p,
    size_t size);

/**
 * Unpack message AI2VCU_Drive_R.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int candata_ai2_vcu_drive_r_unpack(
    struct candata_ai2_vcu_drive_r_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t candata_ai2_vcu_drive_r_rear_axle_trq_request_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_ai2_vcu_drive_r_rear_axle_trq_request_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_ai2_vcu_drive_r_rear_axle_trq_request_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t candata_ai2_vcu_drive_r_rear_motor_speed_max_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_ai2_vcu_drive_r_rear_motor_speed_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_ai2_vcu_drive_r_rear_motor_speed_max_is_in_range(uint16_t value);

/**
 * Pack message VCU2AI_Wheel_counts.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int candata_vcu2_ai_wheel_counts_pack(
    uint8_t *dst_p,
    const struct candata_vcu2_ai_wheel_counts_t *src_p,
    size_t size);

/**
 * Unpack message VCU2AI_Wheel_counts.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int candata_vcu2_ai_wheel_counts_unpack(
    struct candata_vcu2_ai_wheel_counts_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t candata_vcu2_ai_wheel_counts_fl_pulse_count_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_wheel_counts_fl_pulse_count_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_wheel_counts_fl_pulse_count_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t candata_vcu2_ai_wheel_counts_fr_pulse_count_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_wheel_counts_fr_pulse_count_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_wheel_counts_fr_pulse_count_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t candata_vcu2_ai_wheel_counts_rl_pulse_count_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_wheel_counts_rl_pulse_count_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_wheel_counts_rl_pulse_count_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t candata_vcu2_ai_wheel_counts_rr_pulse_count_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu2_ai_wheel_counts_rr_pulse_count_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu2_ai_wheel_counts_rr_pulse_count_is_in_range(uint16_t value);

/**
 * Pack message VCU_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int candata_vcu_status_pack(
    uint8_t *dst_p,
    const struct candata_vcu_status_t *src_p,
    size_t size);

/**
 * Unpack message VCU_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int candata_vcu_status_unpack(
    struct candata_vcu_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu_status_sm_sys_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu_status_sm_sys_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu_status_sm_sys_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu_status_sm_as_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu_status_sm_as_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu_status_sm_as_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu_status_r1_ai2_vcu_status_timeout_error_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu_status_r1_ai2_vcu_status_timeout_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu_status_r1_ai2_vcu_status_timeout_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu_status_r1_ai2_vcu_drive_f_timeout_error_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu_status_r1_ai2_vcu_drive_f_timeout_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu_status_r1_ai2_vcu_drive_f_timeout_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu_status_r1_ai2_vcu_drive_r_timeout_error_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu_status_r1_ai2_vcu_drive_r_timeout_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu_status_r1_ai2_vcu_drive_r_timeout_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu_status_r1_ai2_vcu_status_handshake_timeout_error_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu_status_r1_ai2_vcu_status_handshake_timeout_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu_status_r1_ai2_vcu_status_handshake_timeout_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu_status_r1_ai2_vcu_steer_timeout_error_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu_status_r1_ai2_vcu_steer_timeout_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu_status_r1_ai2_vcu_steer_timeout_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu_status_r1_ai2_vcu_brake_timeout_error_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu_status_r1_ai2_vcu_brake_timeout_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu_status_r1_ai2_vcu_brake_timeout_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu_status_sys_action_state_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu_status_sys_action_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu_status_sys_action_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu_status_warn_brake_plausibility_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu_status_warn_brake_plausibility_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu_status_warn_brake_plausibility_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu_status_warn_kl15_under_v_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu_status_warn_kl15_under_v_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu_status_warn_kl15_under_v_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu_status_warn_ai_estop_req_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu_status_warn_ai_estop_req_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu_status_warn_ai_estop_req_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu_status_warn_ai_comms_lost_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu_status_warn_ai_comms_lost_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu_status_warn_ai_comms_lost_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu_status_warn_auto_braking_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu_status_warn_auto_braking_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu_status_warn_auto_braking_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t candata_vcu_status_warn_mission_status_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float candata_vcu_status_warn_mission_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool candata_vcu_status_warn_mission_status_is_in_range(uint8_t value);


#ifdef __cplusplus
}
#endif

#endif
